from ./operations import UnaryOperation, BinaryOperation
from ./utils import logger, raw
from ./var_types import List, Int, qInt, var_types_from_string

StaticVar = None
DataSource = None
ScoreSource = None

def provide_sources(data_source, score_source, static_var):
    """
    Hacky solution to expose this module to necessary classes while avoiding circular imports.
    """
    global StaticVar, DataSource, ScoreSource

    DataSource = data_source
    ScoreSource = score_source
    StaticVar = static_var

len_copy = len
def len(target):
    if isinstance(target, DataSource) and target.get_type() in ['list', 'compound', 'string', 'byte_array', 'int_array', 'long_array']:
        return Length(target)
    else:
        # Fall back to default implementation
        return len_copy(target)

class Length(UnaryOperation):
    """
    Checks if data exists.
    """
    def condition_impl(self):
        self.result()

        with self.store_success():
            if not self.inverted:
                unless score self.outcome.holder self.outcome.obj matches 0
            else:
                if score self.outcome.holder self.outcome.obj matches 0

    def result_impl(self):
        """
        Since this is a boolean operation, the result is the same as the condition.
        """
        with self.store_result():
            if self.expr._type == 'storage':
                data get storage self.expr._target self.expr._path
            elif self.expr._type == 'entity':
                data get entity self.expr._target self.expr._path
            elif self.expr._type == 'block':
                data get block self.expr._target self.expr._path
            else:
                logger.error(f"Unsupported expression type '{self.expr._type}'. Type must be 'storage', 'entity' or 'block'.")
                exit()

class ListContains(BinaryOperation):
    """
    Checks if a value is inside a list or array.
    Called when using `val in list`.
    """
    def condition(self):
        # Get length of the data.
        length_op = Length(self.left)
        length_op.outcome = StaticVar(qInt)
        length_op.result()

        # Transfer the target data to storage (if needed).
        # If the target is a literal, we set from the value instead.
        target_storage = None
        if isinstance(self.right, DataSource):
            target_storage = self.right
        elif isinstance(self.right, ScoreSource):
            target_storage = StaticVar(Int)
            target_storage = self.right

        # Get number of differing entries.
        temp_data = StaticVar(var_types_from_string[self.left.get_type()])
        temp_data = self.left
        diff_score = StaticVar(qInt)
        with diff_score.store('result', None, 1):
            if target_storage is not None:
                temp_data[] = target_storage
            else:
                temp_data[] = self.right

        # List contains value if there is at least one
        # element that is not different from the containing value.
        with self.store_success():
            unless score var length_op.outcome = var diff_score
